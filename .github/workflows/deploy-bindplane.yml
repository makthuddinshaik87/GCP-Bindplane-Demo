
name: BindPlane GCP Demo Deployment (Strict Active Gates)

on:
  workflow_dispatch:

concurrency:
  group: bindplane-gcp-demo-${{ github.ref }}
  cancel-in-progress: false

env:
  TF_VERSION: 1.6.6

jobs:
  # =========================================================
  # PART 1 – CLOUD SQL POSTGRESQL
  # =========================================================
  part1-db:
    name: Part 1 – Cloud SQL PostgreSQL (Wait Until ACTIVE)
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Cache Terraform plugins
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            terraform/.terraform.d/plugin-cache
          key: tf-${{ runner.os }}-${{ env.TF_VERSION }}-${{ hashFiles('**/*.tf') }}

      - name: Authenticate to GCP (Workload Identity / SA Key)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '>= 426.0.0' # Recent enough for Cloud SQL commands

      - name: Install utils (curl, jq, netcat)
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq netcat

      - name: Terraform fmt & validate (fail fast)
        working-directory: terraform/part1-db
        env:
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
        run: |
          terraform fmt -recursive
          terraform validate

      - name: Terraform Init – Cloud SQL
        working-directory: terraform/part1-db
        env:
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_project_id:     ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_region:         ${{ secrets.GCP_REGION }}
          TF_VAR_db_password:    ${{ secrets.DB_PASSWORD }}
          TF_VAR_db_admin:       ${{ secrets.DB_ADMIN }}
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
        run: |
          terraform init -input=false

      - name: Terraform Apply – Cloud SQL
        working-directory: terraform/part1-db
        env:
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
        run: |
          terraform apply -auto-approve -input=false -lock-timeout=300s

      - name: Wait until Cloud SQL PostgreSQL is RUNNABLE
        env:
          GCLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
        run: |
          echo "Waiting for Cloud SQL instance to be RUNNABLE..."
          for i in {1..40}; do
            STATE=$(gcloud sql instances describe bp-postgres \
              --project "$GCLOUD_PROJECT" \
              --format="value(state)") || STATE="UNKNOWN"
            echo "Current state: $STATE"
            if [ "$STATE" = "RUNNABLE" ]; then
              echo "Cloud SQL PostgreSQL is ACTIVE"
              exit 0
            fi
            sleep 15
          done
          echo "Cloud SQL did not become ACTIVE within timeout"
          exit 1

  # =========================================================
  # PART 2 – BINDPLANE CONTROL PLANE
  # =========================================================
  part2-control-plane:
    name: Part 2 – BindPlane Control Plane (Wait Until ACTIVE)
    runs-on: ubuntu-latest
    needs: part1-db
    timeout-minutes: 40
    outputs:
      control_plane_ip: ${{ steps.cp_output.outputs.control_plane_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Cache Terraform plugins
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            terraform/.terraform.d/plugin-cache
          key: tf-${{ runner.os }}-${{ env.TF_VERSION }}-${{ hashFiles('**/*.tf') }}

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '>= 426.0.0'

      - name: Install utils (curl, jq, netcat)
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq netcat

      - name: Terraform fmt & validate (fail fast)
        working-directory: terraform/part2-control-plane
        env:
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
        run: |
          terraform fmt -recursive
          terraform validate

      - name: DEBUG – show main.tf exactly
        working-directory: terraform/part2-control-plane
        run: |
           pwd
           echo "===== LIST FILES ====="
           ls -l
           echo "===== SHOW main.tf ====="
           nl -ba main.tf | sed -n '1,120p'

      - name: Terraform Init – Control Plane
        working-directory: terraform/part2-control-plane
        env:
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_project_id:     ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_region:         ${{ secrets.GCP_REGION }}
          TF_VAR_admin_password: ${{ secrets.BINDPLANE_ADMIN_PASSWORD }}
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
        run: terraform init -input=false

      - name: Terraform Apply – Control Plane
        working-directory: terraform/part2-control-plane
        env:
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache
        run: terraform apply -auto-approve -input=false -lock-timeout=300s

      - name: Capture Control Plane IP (output)
        id: cp_output
        working-directory: terraform/part2-control-plane
        run: |
          CP_IP=$(terraform output -raw control_plane_ip)
          # Mask the IP just for consistency in logs (not secret, but clean)
          echo "::add-mask::$CP_IP"
          echo "control_plane_ip=$CP_IP" >> "$GITHUB_OUTPUT"

      - name: Wait until BindPlane Control Plane is ACTIVE (HTTP Health or Port)
        run: |
          CP_IP="${{ steps.cp_output.outputs.control_plane_ip }}"
          echo "Waiting for BindPlane UI on http://$CP_IP:3001"
          # Try HTTP health endpoint first; fallback to port check.
          for i in {1..40}; do
            if curl -sf "http://$CP_IP:3001/health" >/dev/null || \
               curl -sf "http://$CP_IP:3001/login"  >/dev/null || \
               curl -sf "http://$CP_IP:3001"        >/dev/null; then
              echo "BindPlane Control Plane HTTP is ACTIVE"
              exit 0
            fi
            # Fallback TCP port check
            if nc -z "$CP_IP" 3001; then
              echo "BindPlane Control Plane port 3001 is open"
              exit 0
            fi
            echo "Control Plane not active yet..."
            sleep 15
          done
          echo "Control Plane did not become ACTIVE within timeout"
          exit 1

  # =========================================================
  # PART 3 – BINDPLANE AGENT
  # =========================================================
  part3-agents:
    name: Part 3 – BindPlane Agent (Wait Until ACTIVE)
    runs-on: ubuntu-latest
    needs: part2-control-plane
    timeout-minutes: 40

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Cache Terraform plugins
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            terraform/.terraform.d/plugin-cache
          key: tf-${{ runner.os }}-${{ env.TF_VERSION }}-${{ hashFiles('**/*.tf') }}
        env:
          TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '>= 426.0.0'

      - name: Install utils (curl, jq, netcat)
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq netcat

      - name: Terraform Init – Agent
        working-directory: terraform/part3-agents
        env:
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_project_id:     ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_region:         ${{ secrets.GCP_REGION }}
        run: terraform init -input=false

      - name: Terraform Apply – Agent
        working-directory: terraform/part3-agents
        env:
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
        run: terraform apply -auto-approve -input=false -lock-timeout=300s

      - name: Wait until Agent is ACTIVE (Registered via API with Auth; fallback port)
        env:
          BINDPLANE_ADMIN_PASSWORD: ${{ secrets.BINDPLANE_ADMIN_PASSWORD }}
        run: |
          CP_IP="${{ needs.part2-control-plane.outputs.control_plane_ip }}"
          echo "Checking agent registration via BindPlane API at http://$CP_IP:3001"

          # Obtain auth token if BindPlane supports password login.
          # Adjust this block to your actual auth flow (Basic/Bearer).
          TOKEN=""
          if curl -sf "http://$CP_IP:3001/api/v1/auth/login" >/dev/null 2>&1; then
            # Example JSON payload for login; replace 'admin' with your admin user if different
            TOKEN=$(curl -sf -X POST "http://$CP_IP:3001/api/v1/auth/login" \
              -H "Content-Type: application/json" \
              -d "{\"username\": \"admin\", \"password\": \"${BINDPLANE_ADMIN_PASSWORD}\"}" | jq -r '.token // empty')
          fi

          for i in {1..40}; do
            if [ -n "$TOKEN" ]; then
              COUNT=$(curl -sf "http://$CP_IP:3001/api/v1/agents" \
                -H "Authorization: Bearer $TOKEN" | jq '.agents | length' 2>/dev/null || echo 0)
            else
              # Unauthenticated check may fail; default to 0.
              COUNT=$(curl -sf "http://$CP_IP:3001/api/v1/agents" | jq '.agents | length' 2>/dev/null || echo 0)
            fi

            echo "Agents detected: $COUNT"
            if [ "$COUNT" -ge 1 ]; then
              echo "BindPlane Agent is ACTIVE and registered"
              exit 0
            fi

            # Fallback: check agent host port (replace values as needed)
            # Example: if agent exposes a health port (e.g., 4318 for OTLP), adapt accordingly.
            # if nc -z "$AGENT_IP" 4318; then
            #   echo "Agent port is open; awaiting registration..."
            # fi

            echo "Agent not active yet..."
            sleep 15
          done
          echo "Agent did not become ACTIVE within timeout"
          exit 1
